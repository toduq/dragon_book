# Dragon Book メモ

## 2章

### 左再帰と右再帰

`expr -> expr + term`みたいなものが、左再帰。
`A -> Aa | b`みたいな文法のときに出てくる。
例えば、`expr -> expr + term | term`みたいな。

TODO: 右再帰とは？

以下のような文法は左再帰。
```
expr -> expr + term { print('+') }
      | expr - term { print('-') }
      | term
term -> /[0-9]/ { print($1) }
```

以下のような変換ができる。
しかしこの形式は、ASTが右結合になってしまう。
```
expr -> term rest
rest -> + term { print('+') } rest
      | - term { print('-') } rest
      | E
term -> /[0-9]/ { print($1) }
```
これに直接対応する、翻訳スキームの変換方法はなく、
LALRを使うか、EBNFなどで繰り返しを導入するなどの必要がある。

上記の文法を実装したのが、[/2_5_postfix_notation.rb](/2_5_postfix_notation.rb)である。

### MEMO : 言語学の英単語

- lexeme(語彙素,レクシーム)
    child/children,go/goes/went/gone/goingなどを区別しない呼び方。
    屈折(日本語の活用形)は同じlexemeになるが、
    名詞のwaterと動詞のwaterは異なったlexemeである。
- lemma(基本形)
    lexemeのうち基本形を指すらしい。child,goなど。
- lexicon(語彙目録)
    lemmmaをまとめたもの。辞書みたいな感じ。

[https://ja.wikipedia.org/wiki/語彙素](https://ja.wikipedia.org/wiki/%E8%AA%9E%E5%BD%99%E7%B4%A0)より。

## 3章

### クリーネ閉包

難しい名前がついているが、Lのクリーネ閉包とは、
Lを文字列として、正規表現`/L*/`にマッチする文字列の集合全体で、LaTeX表記で`L^*`として書かれる。
正のクリーネ閉包は`/L+/`であり、`L^+`として書かれるものである。
単純明快だ。

このKleeneさんは、和、連結、クリーネ閉包によって正規表現を作った人。
ただし、この正規表現とは、今の正規表現よりもっとプリミティブなものである。

### MEMO: 決定性/非決定性 有限オートマトン

- 決定性有限オートマトン(DFA: Deterministic Finite Automaton)
- 非決定性有限オートマトン(NFA: Nendeterministic Finite Automaton)

決定性は、オートマトンのうち、遷移が必ず１通りに定まるもの。
非決定性は、入力に対して遷移が複数パターン存在するようなものを許容する。

Automatonの複数形はAutomata

### トライ木

TrieはRetrievalから来ていて正しい発音はトゥリーだが、Treeと紛らわしいのでトライと呼ぶことが多い。
決定性有限オートマトンでもある。

文字列の集合の木構造へのマッピングのようなもので、
ルートが空の文字列であって、
枝がそれぞれ、次の文字によって分離していく。
1文字進むごとに1つの葉を作る。
子供が1つしかない葉を親とマージ(2文字以上同時に進むことを許容する)したものを、パトリシア木という。

### 失敗関数

f(s)で、状態がsのときにマッチに失敗したとき、
いままで一致させた文字列のうち、トライ木から辿ったときに、最も長くマッチするもじを探してきて、
その状態をf(s)の値として、マッチに失敗したときには、0に戻る代わりにf(s)に遷移するようにする。

言い換えると、マッチが失敗したときに、
今までマッチさせた文字列をT(t1 t2 t3 ... ts)として、
マッチングしたい文字列B(= b1 b2 b3 ... bn)において、
そのBの真の頭部の集合(b1, b1 b2, b1 b2 b3, ...)のうちの、
Sの尾部にマッチする最も長い頭部を見つけてきて、
そこまでマッチしたものとして、マッチを再開するということである。

例えば、ababaaというトライがあったとき、
```
a     でマッチングに失敗したら、a/ababaaの共通部分なので、f(1) = 0
ab    でマッチングに失敗したら、ab/ababaaなので、f(2) = 0
aba   でマッチングに失敗したら、ab[a/a]babaaなので、f(3) = 1
abab  でマッチングに失敗したら、ab[ab/ab]abaaなので、f(4) = 2
ababa でマッチングに失敗したら、ab[aba/aba]baaなので、f(5) = 3
ababaaでマッチングに失敗したら、ababa[a/a]babaaなので、f(1) = 1
```
という話。
